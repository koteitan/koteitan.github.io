<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>ReTern-Key パズル（HTML）</title>
<style>
  body{font-family:system-ui, -apple-system, "Segoe UI", Roboto, "Helvetica Neue", Arial; padding:20px; background:#f6f7fb; color:#111;}
  h1{font-size:18px;margin:0 0 12px}
  .controls{display:flex;gap:8px;align-items:center;margin-bottom:12px}
  input[type=number]{width:72px;padding:6px;border-radius:6px;border:1px solid #c8ccd8}
  button{padding:8px 10px;border-radius:6px;border:1px solid #9aa4bf;background:#fff;cursor:pointer}
  #board{display:flex;gap:10px;flex-wrap:wrap;margin-bottom:12px}
  .stage{width:96px;height:120px;background:#fff;border-radius:10px;border:1px solid #d8dbe8;display:flex;flex-direction:column;align-items:center;justify-content:center;box-shadow:0 1px 2px rgba(10,10,20,0.04)}
  .stateBox{width:64px;height:64px;border-radius:8px;display:flex;align-items:center;justify-content:center;font-weight:700;color:#fff;font-size:18px;margin-bottom:8px}
  .s0{background:#9aa0a6;color:#fff} /* state 0 */
  .s1{background:#f39a3c} /* state 1 */
  .s2{background:#2b9f5a} /* state 2 */
  .controls-row{display:flex;gap:6px}
  .small{font-size:12px;color:#555}
  #log{font-family:monospace;background:#fff;padding:8px;border-radius:8px;border:1px solid #e2e6f0;max-height:160px;overflow:auto}
  .disabled{opacity:.45;pointer-events:none}
  .solved{background:linear-gradient(90deg,#e6f9ef,#f0fff6);border-color:#bfe8cd}
</style>
</head>
<body>
<h1>ReTern-Key（簡易実装）</h1>

<div class="controls">
  <label class="small">ステージ数
    <input id="stagesCount" type="number" min="1" max="12" value="3">
  </label>
  <button id="applyCount">反映</button>
  <button id="scramble">スクランブル</button>
  <button id="reset">リセット</button>
  <div style="margin-left:auto">
    <span class="small">手数: </span><span id="moves">0</span>
  </div>
</div>

<div id="board" aria-live="polite"></div>

<div style="display:flex;gap:12px;align-items:flex-start">
  <div style="flex:1">
    <div class="small" style="margin-bottom:6px">ルール（実装）</div>
    <ul class="small">
      <li>状態は 0 → 1 → 2 の順でのみ変化可能（直接 2 → 0 や 0 → 2 は不可）。</li>
      <li>あるステージを 0 ⇄ 1 に変えるには、右側の全てのステージが状態 2 であること。</li>
      <li>あるステージを 1 ⇄ 2 に変えるには、右側の全てのステージが状態 0 であること。</li>
    </ul>
  </div>
  <div style="width:320px">
    <div class="small" style="margin-bottom:6px">操作ログ</div>
    <div id="log"></div>
  </div>
</div>

<script>
(function(){
  const boardEl = document.getElementById('board');
  const movesEl = document.getElementById('moves');
  const logEl = document.getElementById('log');
  const stagesCountInput = document.getElementById('stagesCount');
  const applyCountBtn = document.getElementById('applyCount');
  const scrambleBtn = document.getElementById('scramble');
  const resetBtn = document.getElementById('reset');

  let states = [];
  let moves = 0;

  function log(msg){
    const time = new Date().toLocaleTimeString();
    logEl.innerText = `[${time}] ${msg}\n` + logEl.innerText;
  }

  function rightAllEqual(index, value){
    for(let i=index+1;i<states.length;i++){
      if(states[i] !== value) return false;
    }
    return true;
  }

  // allowed transition check: from cur -> target (target = cur +/- 1)
  function allowedTransition(index, target){
    const cur = states[index];
    if(Math.abs(target - cur) !== 1) return false; // only ±1 allowed
    // 0 <-> 1 rules
    if((cur === 0 && target === 1) || (cur === 1 && target === 0)){
      return rightAllEqual(index, 2);
    }
    // 1 <-> 2 rules
    if((cur === 1 && target === 2) || (cur === 2 && target === 1)){
      return rightAllEqual(index, 0);
    }
    return false;
  }

  function render(){
    boardEl.innerHTML = '';
    states.forEach((s,i) => {
      const st = document.createElement('div');
      st.className = 'stage' + (isSolved() ? ' solved' : '');
      const box = document.createElement('div');
      box.className = 'stateBox s' + s;
      box.innerText = s;
      const idx = document.createElement('div');
      idx.className = 'small';
      idx.innerText = `#${i+1}`;
      const controls = document.createElement('div');
      controls.className = 'controls-row';
      const btnInc = document.createElement('button');
      btnInc.innerText = '+';
      const btnDec = document.createElement('button');
      btnDec.innerText = '−';
      // attach handlers
      btnInc.addEventListener('click', ()=> tryChange(i, s+1));
      btnDec.addEventListener('click', ()=> tryChange(i, s-1));
      // disable if not allowed
      if(!allowedTransition(i, s+1)) btnInc.classList.add('disabled');
      if(!allowedTransition(i, s-1)) btnDec.classList.add('disabled');

      controls.appendChild(btnDec);
      controls.appendChild(btnInc);

      st.appendChild(box);
      st.appendChild(idx);
      st.appendChild(controls);
      boardEl.appendChild(st);
    });
    movesEl.innerText = moves;
  }

  function tryChange(index, target){
    if(target < 0 || target > 2) return;
    if(!allowedTransition(index, target)){
      log(`禁止された移動: ステージ ${index+1} を ${states[index]} → ${target}`);
      return;
    }
    const prev = states[index];
    states[index] = target;
    moves++;
    log(`移動: ステージ ${index+1} ${prev} → ${target}`);
    render();
    if(isSolved()){
      log('達成: 全ステージが状態 2 です（Solved）');
    }
  }

  function isSolved(){
    return states.length > 0 && states.every(s => s === 2);
  }

  function reset(n){
    states = Array(n).fill(0);
    moves = 0;
    log(`リセット: ${n} ステージを 0 にセット`);
    render();
  }

  // scramble by performing random valid moves from solved or from reset
  function scramble(n, steps=200){
    // start from all 0 to allow valid forward moves
    states = Array(n).fill(0);
    moves = 0;
    // collect all possible valid moves and apply random ones
    const possibleMoves = () => {
      const arr = [];
      for(let i=0;i<states.length;i++){
        const cur = states[i];
        if(cur+1 <= 2 && allowedTransition(i, cur+1)) arr.push([i, cur+1]);
        if(cur-1 >= 0 && allowedTransition(i, cur-1)) arr.push([i, cur-1]);
      }
      return arr;
    };
    // perform steps
    for(let s=0;s<steps;s++){
      const pm = possibleMoves();
      if(pm.length === 0) break;
      const choice = pm[Math.floor(Math.random()*pm.length)];
      states[choice[0]] = choice[1];
    }
    moves = 0;
    log(`スクランブル実行（推定 ${steps} 回のランダム試行）`);
    render();
  }

  applyCountBtn.addEventListener('click', ()=>{
    const n = parseInt(stagesCountInput.value) || 3;
    const bounded = Math.max(1, Math.min(12, n));
    stagesCountInput.value = bounded;
    reset(bounded);
  });

  scrambleBtn.addEventListener('click', ()=>{
    const n = parseInt(stagesCountInput.value) || 3;
    scramble(n, 300);
  });

  resetBtn.addEventListener('click', ()=>{
    const n = parseInt(stagesCountInput.value) || 3;
    reset(n);
  });

  // initial
  reset(parseInt(stagesCountInput.value)||3);
})();
</script>
</body>
</html>