<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>スワイプ追従スライディングパズル</title>
<style>
  body,html{margin:0;padding:0;overflow:hidden;background:#f0f2f5;touch-action:none;}
  canvas{display:block;margin:auto;background:#fff;touch-action:none;}
</style>
</head>
<body>
<canvas id="puzzle" width="600" height="600"></canvas>
<script>
const mapData=[
"111111111111",
"1a111b111c11",
"1a111b111c11",
"1aa11bb11cc1",
"1adddbeeec01",
"1a011b011c01",
"10fff0ggg001",
"100110011001",
"101110111011",
"101110111011",
"111111111111"
];
const rows=mapData.length, cols=mapData[0].length;
const canvas=document.getElementById("puzzle"), ctx=canvas.getContext("2d");
const cellSize=Math.floor(canvas.width/cols);

const colors={a:"#e74c3c",b:"#e74c3c",c:"#e74c3c",d:"#00bcd4",e:"#00bcd4",f:"#00bcd4",g:"#00bcd4"};

let walls=[],pieces={};
for(let y=0;y<rows;y++){
  for(let x=0;x<cols;x++){
    const ch=mapData[y][x];
    if(ch==="1") walls.push({x,y});
    else if(ch!=="0"){
      if(!pieces[ch]) pieces[ch]={id:ch,cells:[],color:colors[ch]};
      pieces[ch].cells.push({x,y});
    }
  }
}

function draw(tempPiece=null){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // 背景
  ctx.fillStyle="#eee";
  for(let y=0;y<rows;y++)for(let x=0;x<cols;x++) if(mapData[y][x]==="0") ctx.fillRect(x*cellSize,y*cellSize,cellSize,cellSize);
  // 壁
  ctx.fillStyle="#444";
  walls.forEach(w=>ctx.fillRect(w.x*cellSize,w.y*cellSize,cellSize,cellSize));
  // ピース
  for(const k in pieces){
    if(tempPiece && tempPiece.id===k) continue; // 一時移動中のは後で描く
    ctx.fillStyle=pieces[k].color;
    pieces[k].cells.forEach(c=>ctx.fillRect(c.x*cellSize+2,c.y*cellSize+2,cellSize-4,cellSize-4));
  }
  if(tempPiece){
    ctx.fillStyle=tempPiece.color;
    tempPiece.cells.forEach(c=>ctx.fillRect(c.x*cellSize+2,c.y*cellSize+2,cellSize-4,cellSize-4));
  }
}

function pieceAt(x,y){
  for(const k in pieces){
    for(const c of pieces[k].cells){
      if(c.x===x&&c.y===y) return pieces[k];
    }
  }
  return null;
}

let dragging=null,dragStartPos=null,pieceStartCells=null;

canvas.addEventListener("touchstart",e=>{
  const t=e.touches[0],rect=canvas.getBoundingClientRect();
  const cx=Math.floor((t.clientX-rect.left)/cellSize);
  const cy=Math.floor((t.clientY-rect.top)/cellSize);
  const p=pieceAt(cx,cy);
  if(p){dragging=p;pieceStartCells=JSON.parse(JSON.stringify(p.cells));dragStartPos={x:t.clientX,y:t.clientY};}
  e.preventDefault();
},{passive:false});

canvas.addEventListener("touchmove",e=>{
  if(!dragging) return;
  const t=e.touches[0];
  const dx=(t.clientX-dragStartPos.x)/cellSize;
  const dy=(t.clientY-dragStartPos.y)/cellSize;
  // ピースの開始位置にオフセットを加算
  const temp={id:dragging.id,color:dragging.color,cells:pieceStartCells.map(c=>({x:c.x+dx,y:c.y+dy}))};
  draw(temp);
  e.preventDefault();
},{passive:false});

canvas.addEventListener("touchend",e=>{
  if(!dragging) return;
  const t=e.changedTouches[0];
  const dx=(t.clientX-dragStartPos.x)/cellSize;
  const dy=(t.clientY-dragStartPos.y)/cellSize;
  // 四捨五入で最終位置確定
  dragging.cells=pieceStartCells.map(c=>({x:Math.round(c.x+dx),y:Math.round(c.y+dy)}));
  dragging=null; pieceStartCells=null; draw();
  e.preventDefault();
},{passive:false});

draw();
</script>
</body>
</html>