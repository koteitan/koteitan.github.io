<!doctype html>
<html lang="ja">
<head>
<meta charset="utf-8">
<title>指定形状スライディングパズル</title>
<style>
  body,html {
    margin:0; padding:0; background:#f0f2f5;
    overflow:hidden; /* ページスクロール禁止 */
    touch-action:none; /* スワイプでスクロールさせない */
  }
  canvas {
    display:block;
    margin:auto;
    background:#fff;
    touch-action:none;
  }
</style>
</head>
<body>
<canvas id="puzzle" width="600" height="600"></canvas>
<script>
const mapData = [
"11111111111",
"1a111b111c11",
"1a111b000c11",
"1aa11bb11cc11",
"1adddbeeec01",
"1a011b011c01",
"10fff0ggg00",
"100110011001",
"101110111011",
"101110111011",
"111111111111"
];

const rows = mapData.length;
const cols = mapData[0].length;
const canvas = document.getElementById("puzzle");
const ctx = canvas.getContext("2d");
const cellSize = Math.floor(canvas.width/cols);

const colors = {
  a:"#e74c3c", b:"#3498db", c:"#9b59b6",
  d:"#f39c12", e:"#1abc9c", f:"#2ecc71",
  g:"#e67e22"
};

let walls = [];
let emptyCells = [];
let pieces = {}; // {id: {cells:[{x,y}], color}}

for(let y=0;y<rows;y++){
  for(let x=0;x<cols;x++){
    const ch = mapData[y][x];
    if(ch==="1"){
      walls.push({x,y});
    }else if(ch==="0"){
      emptyCells.push({x,y});
    }else{
      if(!pieces[ch]){
        pieces[ch] = {id:ch,cells:[],color:colors[ch]||"#555"};
      }
      pieces[ch].cells.push({x,y});
    }
  }
}

function draw(){
  ctx.clearRect(0,0,canvas.width,canvas.height);
  // walls
  ctx.fillStyle="#444";
  walls.forEach(w=>{
    ctx.fillRect(w.x*cellSize, w.y*cellSize, cellSize, cellSize);
  });
  // empty
  ctx.fillStyle="#eee";
  emptyCells.forEach(c=>{
    ctx.fillRect(c.x*cellSize, c.y*cellSize, cellSize, cellSize);
  });
  // pieces
  for(const k in pieces){
    const p=pieces[k];
    ctx.fillStyle=p.color;
    p.cells.forEach(c=>{
      ctx.fillRect(c.x*cellSize+2, c.y*cellSize+2, cellSize-4, cellSize-4);
    });
  }
}

function occupiedMap(ignoreId=null){
  const occ = Array.from({length:rows},()=>Array(cols).fill(null));
  walls.forEach(w=>occ[w.y][w.x]="wall");
  for(const k in pieces){
    if(k===ignoreId) continue;
    pieces[k].cells.forEach(c=>occ[c.y][c.x]=k);
  }
  return occ;
}

function canMove(pieceId, dx, dy){
  const occ = occupiedMap(pieceId);
  const pcs = pieces[pieceId].cells;
  for(const c of pcs){
    const nx=c.x+dx, ny=c.y+dy;
    if(nx<0||nx>=cols||ny<0||ny>=rows) return false;
    if(occ[ny][nx]!=null) return false;
  }
  return true;
}

function movePiece(pieceId, dx, dy){
  if(!canMove(pieceId,dx,dy)) return false;
  pieces[pieceId].cells.forEach(c=>{c.x+=dx;c.y+=dy;});
  return true;
}

function pieceAt(x,y){
  for(const k in pieces){
    for(const c of pieces[k].cells){
      if(c.x===x && c.y===y) return pieces[k];
    }
  }
  return null;
}

// swipe detection
let startX=null, startY=null, swipedPiece=null;
canvas.addEventListener("touchstart",e=>{
  const t=e.touches[0];
  const rect=canvas.getBoundingClientRect();
  const cx=Math.floor((t.clientX-rect.left)/cellSize);
  const cy=Math.floor((t.clientY-rect.top)/cellSize);
  swipedPiece=pieceAt(cx,cy);
  startX=t.clientX;
  startY=t.clientY;
  e.preventDefault();
},{passive:false});

canvas.addEventListener("touchend",e=>{
  if(!swipedPiece) return;
  const dx=e.changedTouches[0].clientX-startX;
  const dy=e.changedTouches[0].clientY-startY;
  if(Math.abs(dx)>Math.abs(dy)){
    if(dx>20) movePiece(swipedPiece.id,1,0);
    if(dx<-20) movePiece(swipedPiece.id,-1,0);
  }else{
    if(dy>20) movePiece(swipedPiece.id,0,1);
    if(dy<-20) movePiece(swipedPiece.id,0,-1);
  }
  swipedPiece=null;
  draw();
  e.preventDefault();
},{passive:false});

draw();
</script>
</body>
</html>